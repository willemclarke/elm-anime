-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module AniList.Query exposing (..)

import AniList.Enum.ActivitySort
import AniList.Enum.ActivityType
import AniList.Enum.AiringSort
import AniList.Enum.CharacterSort
import AniList.Enum.LikeableType
import AniList.Enum.MediaFormat
import AniList.Enum.MediaListSort
import AniList.Enum.MediaListStatus
import AniList.Enum.MediaSeason
import AniList.Enum.MediaSort
import AniList.Enum.MediaSource
import AniList.Enum.MediaStatus
import AniList.Enum.MediaTrendSort
import AniList.Enum.MediaType
import AniList.Enum.NotificationType
import AniList.Enum.RecommendationSort
import AniList.Enum.ReviewSort
import AniList.Enum.StaffSort
import AniList.Enum.StudioSort
import AniList.Enum.ThreadCommentSort
import AniList.Enum.ThreadSort
import AniList.Enum.UserSort
import AniList.InputObject
import AniList.Interface
import AniList.Object
import AniList.Scalar
import AniList.ScalarCodecs
import AniList.Union
import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.Operation exposing (RootMutation, RootQuery, RootSubscription)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode exposing (Decoder)


type alias PageOptionalArguments =
    { page : OptionalArgument Int
    , perPage : OptionalArgument Int
    }


{-|

  - page - The page number
  - perPage - The amount of entries per page, max 50

-}
page :
    (PageOptionalArguments -> PageOptionalArguments)
    -> SelectionSet decodesTo AniList.Object.Page
    -> SelectionSet (Maybe decodesTo) RootQuery
page fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { page = Absent, perPage = Absent }

        optionalArgs____ =
            [ Argument.optional "page" filledInOptionals____.page Encode.int, Argument.optional "perPage" filledInOptionals____.perPage Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "Page" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias MediaOptionalArguments =
    { id : OptionalArgument Int
    , idMal : OptionalArgument Int
    , startDate : OptionalArgument AniList.ScalarCodecs.FuzzyDateInt
    , endDate : OptionalArgument AniList.ScalarCodecs.FuzzyDateInt
    , season : OptionalArgument AniList.Enum.MediaSeason.MediaSeason
    , seasonYear : OptionalArgument Int
    , type_ : OptionalArgument AniList.Enum.MediaType.MediaType
    , format : OptionalArgument AniList.Enum.MediaFormat.MediaFormat
    , status : OptionalArgument AniList.Enum.MediaStatus.MediaStatus
    , episodes : OptionalArgument Int
    , duration : OptionalArgument Int
    , chapters : OptionalArgument Int
    , volumes : OptionalArgument Int
    , isAdult : OptionalArgument Bool
    , genre : OptionalArgument String
    , tag : OptionalArgument String
    , minimumTagRank : OptionalArgument Int
    , tagCategory : OptionalArgument String
    , onList : OptionalArgument Bool
    , licensedBy : OptionalArgument String
    , averageScore : OptionalArgument Int
    , popularity : OptionalArgument Int
    , source : OptionalArgument AniList.Enum.MediaSource.MediaSource
    , countryOfOrigin : OptionalArgument AniList.ScalarCodecs.CountryCode
    , isLicensed : OptionalArgument Bool
    , search : OptionalArgument String
    , id_not : OptionalArgument Int
    , id_in : OptionalArgument (List (Maybe Int))
    , id_not_in : OptionalArgument (List (Maybe Int))
    , idMal_not : OptionalArgument Int
    , idMal_in : OptionalArgument (List (Maybe Int))
    , idMal_not_in : OptionalArgument (List (Maybe Int))
    , startDate_greater : OptionalArgument AniList.ScalarCodecs.FuzzyDateInt
    , startDate_lesser : OptionalArgument AniList.ScalarCodecs.FuzzyDateInt
    , startDate_like : OptionalArgument String
    , endDate_greater : OptionalArgument AniList.ScalarCodecs.FuzzyDateInt
    , endDate_lesser : OptionalArgument AniList.ScalarCodecs.FuzzyDateInt
    , endDate_like : OptionalArgument String
    , format_in : OptionalArgument (List (Maybe AniList.Enum.MediaFormat.MediaFormat))
    , format_not : OptionalArgument AniList.Enum.MediaFormat.MediaFormat
    , format_not_in : OptionalArgument (List (Maybe AniList.Enum.MediaFormat.MediaFormat))
    , status_in : OptionalArgument (List (Maybe AniList.Enum.MediaStatus.MediaStatus))
    , status_not : OptionalArgument AniList.Enum.MediaStatus.MediaStatus
    , status_not_in : OptionalArgument (List (Maybe AniList.Enum.MediaStatus.MediaStatus))
    , episodes_greater : OptionalArgument Int
    , episodes_lesser : OptionalArgument Int
    , duration_greater : OptionalArgument Int
    , duration_lesser : OptionalArgument Int
    , chapters_greater : OptionalArgument Int
    , chapters_lesser : OptionalArgument Int
    , volumes_greater : OptionalArgument Int
    , volumes_lesser : OptionalArgument Int
    , genre_in : OptionalArgument (List (Maybe String))
    , genre_not_in : OptionalArgument (List (Maybe String))
    , tag_in : OptionalArgument (List (Maybe String))
    , tag_not_in : OptionalArgument (List (Maybe String))
    , tagCategory_in : OptionalArgument (List (Maybe String))
    , tagCategory_not_in : OptionalArgument (List (Maybe String))
    , licensedBy_in : OptionalArgument (List (Maybe String))
    , averageScore_not : OptionalArgument Int
    , averageScore_greater : OptionalArgument Int
    , averageScore_lesser : OptionalArgument Int
    , popularity_not : OptionalArgument Int
    , popularity_greater : OptionalArgument Int
    , popularity_lesser : OptionalArgument Int
    , source_in : OptionalArgument (List (Maybe AniList.Enum.MediaSource.MediaSource))
    , sort : OptionalArgument (List (Maybe AniList.Enum.MediaSort.MediaSort))
    }


{-| Media query

  - id - Filter by the media id
  - idMal - Filter by the media's MyAnimeList id
  - startDate - Filter by the start date of the media
  - endDate - Filter by the end date of the media
  - season - Filter by the season the media was released in
  - seasonYear - The year of the season (Winter 2017 would also include December 2016 releases). Requires season argument
  - type\_ - Filter by the media's type
  - format - Filter by the media's format
  - status - Filter by the media's current release status
  - episodes - Filter by amount of episodes the media has
  - duration - Filter by the media's episode length
  - chapters - Filter by the media's chapter count
  - volumes - Filter by the media's volume count
  - isAdult - Filter by if the media's intended for 18+ adult audiences
  - genre - Filter by the media's genres
  - tag - Filter by the media's tags
  - minimumTagRank - Only apply the tags filter argument to tags above this rank. Default: 18
  - tagCategory - Filter by the media's tags with in a tag category
  - onList - Filter by the media on the authenticated user's lists
  - licensedBy - Filter media by sites with a online streaming or reading license
  - averageScore - Filter by the media's average score
  - popularity - Filter by the number of users with this media on their list
  - source - Filter by the source type of the media
  - countryOfOrigin - Filter by the media's country of origin
  - isLicensed - If the media is officially licensed or a self-published doujin release
  - search - Filter by search query
  - id\_not - Filter by the media id
  - id\_in - Filter by the media id
  - id\_not\_in - Filter by the media id
  - idMal\_not - Filter by the media's MyAnimeList id
  - idMal\_in - Filter by the media's MyAnimeList id
  - idMal\_not\_in - Filter by the media's MyAnimeList id
  - startDate\_greater - Filter by the start date of the media
  - startDate\_lesser - Filter by the start date of the media
  - startDate\_like - Filter by the start date of the media
  - endDate\_greater - Filter by the end date of the media
  - endDate\_lesser - Filter by the end date of the media
  - endDate\_like - Filter by the end date of the media
  - format\_in - Filter by the media's format
  - format\_not - Filter by the media's format
  - format\_not\_in - Filter by the media's format
  - status\_in - Filter by the media's current release status
  - status\_not - Filter by the media's current release status
  - status\_not\_in - Filter by the media's current release status
  - episodes\_greater - Filter by amount of episodes the media has
  - episodes\_lesser - Filter by amount of episodes the media has
  - duration\_greater - Filter by the media's episode length
  - duration\_lesser - Filter by the media's episode length
  - chapters\_greater - Filter by the media's chapter count
  - chapters\_lesser - Filter by the media's chapter count
  - volumes\_greater - Filter by the media's volume count
  - volumes\_lesser - Filter by the media's volume count
  - genre\_in - Filter by the media's genres
  - genre\_not\_in - Filter by the media's genres
  - tag\_in - Filter by the media's tags
  - tag\_not\_in - Filter by the media's tags
  - tagCategory\_in - Filter by the media's tags with in a tag category
  - tagCategory\_not\_in - Filter by the media's tags with in a tag category
  - licensedBy\_in - Filter media by sites with a online streaming or reading license
  - averageScore\_not - Filter by the media's average score
  - averageScore\_greater - Filter by the media's average score
  - averageScore\_lesser - Filter by the media's average score
  - popularity\_not - Filter by the number of users with this media on their list
  - popularity\_greater - Filter by the number of users with this media on their list
  - popularity\_lesser - Filter by the number of users with this media on their list
  - source\_in - Filter by the source type of the media
  - sort - The order the results will be returned in

-}
media :
    (MediaOptionalArguments -> MediaOptionalArguments)
    -> SelectionSet decodesTo AniList.Object.Media
    -> SelectionSet (Maybe decodesTo) RootQuery
media fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { id = Absent, idMal = Absent, startDate = Absent, endDate = Absent, season = Absent, seasonYear = Absent, type_ = Absent, format = Absent, status = Absent, episodes = Absent, duration = Absent, chapters = Absent, volumes = Absent, isAdult = Absent, genre = Absent, tag = Absent, minimumTagRank = Absent, tagCategory = Absent, onList = Absent, licensedBy = Absent, averageScore = Absent, popularity = Absent, source = Absent, countryOfOrigin = Absent, isLicensed = Absent, search = Absent, id_not = Absent, id_in = Absent, id_not_in = Absent, idMal_not = Absent, idMal_in = Absent, idMal_not_in = Absent, startDate_greater = Absent, startDate_lesser = Absent, startDate_like = Absent, endDate_greater = Absent, endDate_lesser = Absent, endDate_like = Absent, format_in = Absent, format_not = Absent, format_not_in = Absent, status_in = Absent, status_not = Absent, status_not_in = Absent, episodes_greater = Absent, episodes_lesser = Absent, duration_greater = Absent, duration_lesser = Absent, chapters_greater = Absent, chapters_lesser = Absent, volumes_greater = Absent, volumes_lesser = Absent, genre_in = Absent, genre_not_in = Absent, tag_in = Absent, tag_not_in = Absent, tagCategory_in = Absent, tagCategory_not_in = Absent, licensedBy_in = Absent, averageScore_not = Absent, averageScore_greater = Absent, averageScore_lesser = Absent, popularity_not = Absent, popularity_greater = Absent, popularity_lesser = Absent, source_in = Absent, sort = Absent }

        optionalArgs____ =
            [ Argument.optional "id" filledInOptionals____.id Encode.int, Argument.optional "idMal" filledInOptionals____.idMal Encode.int, Argument.optional "startDate" filledInOptionals____.startDate (AniList.ScalarCodecs.codecs |> AniList.Scalar.unwrapEncoder .codecFuzzyDateInt), Argument.optional "endDate" filledInOptionals____.endDate (AniList.ScalarCodecs.codecs |> AniList.Scalar.unwrapEncoder .codecFuzzyDateInt), Argument.optional "season" filledInOptionals____.season (Encode.enum AniList.Enum.MediaSeason.toString), Argument.optional "seasonYear" filledInOptionals____.seasonYear Encode.int, Argument.optional "type" filledInOptionals____.type_ (Encode.enum AniList.Enum.MediaType.toString), Argument.optional "format" filledInOptionals____.format (Encode.enum AniList.Enum.MediaFormat.toString), Argument.optional "status" filledInOptionals____.status (Encode.enum AniList.Enum.MediaStatus.toString), Argument.optional "episodes" filledInOptionals____.episodes Encode.int, Argument.optional "duration" filledInOptionals____.duration Encode.int, Argument.optional "chapters" filledInOptionals____.chapters Encode.int, Argument.optional "volumes" filledInOptionals____.volumes Encode.int, Argument.optional "isAdult" filledInOptionals____.isAdult Encode.bool, Argument.optional "genre" filledInOptionals____.genre Encode.string, Argument.optional "tag" filledInOptionals____.tag Encode.string, Argument.optional "minimumTagRank" filledInOptionals____.minimumTagRank Encode.int, Argument.optional "tagCategory" filledInOptionals____.tagCategory Encode.string, Argument.optional "onList" filledInOptionals____.onList Encode.bool, Argument.optional "licensedBy" filledInOptionals____.licensedBy Encode.string, Argument.optional "averageScore" filledInOptionals____.averageScore Encode.int, Argument.optional "popularity" filledInOptionals____.popularity Encode.int, Argument.optional "source" filledInOptionals____.source (Encode.enum AniList.Enum.MediaSource.toString), Argument.optional "countryOfOrigin" filledInOptionals____.countryOfOrigin (AniList.ScalarCodecs.codecs |> AniList.Scalar.unwrapEncoder .codecCountryCode), Argument.optional "isLicensed" filledInOptionals____.isLicensed Encode.bool, Argument.optional "search" filledInOptionals____.search Encode.string, Argument.optional "id_not" filledInOptionals____.id_not Encode.int, Argument.optional "id_in" filledInOptionals____.id_in (Encode.int |> Encode.maybe |> Encode.list), Argument.optional "id_not_in" filledInOptionals____.id_not_in (Encode.int |> Encode.maybe |> Encode.list), Argument.optional "idMal_not" filledInOptionals____.idMal_not Encode.int, Argument.optional "idMal_in" filledInOptionals____.idMal_in (Encode.int |> Encode.maybe |> Encode.list), Argument.optional "idMal_not_in" filledInOptionals____.idMal_not_in (Encode.int |> Encode.maybe |> Encode.list), Argument.optional "startDate_greater" filledInOptionals____.startDate_greater (AniList.ScalarCodecs.codecs |> AniList.Scalar.unwrapEncoder .codecFuzzyDateInt), Argument.optional "startDate_lesser" filledInOptionals____.startDate_lesser (AniList.ScalarCodecs.codecs |> AniList.Scalar.unwrapEncoder .codecFuzzyDateInt), Argument.optional "startDate_like" filledInOptionals____.startDate_like Encode.string, Argument.optional "endDate_greater" filledInOptionals____.endDate_greater (AniList.ScalarCodecs.codecs |> AniList.Scalar.unwrapEncoder .codecFuzzyDateInt), Argument.optional "endDate_lesser" filledInOptionals____.endDate_lesser (AniList.ScalarCodecs.codecs |> AniList.Scalar.unwrapEncoder .codecFuzzyDateInt), Argument.optional "endDate_like" filledInOptionals____.endDate_like Encode.string, Argument.optional "format_in" filledInOptionals____.format_in (Encode.enum AniList.Enum.MediaFormat.toString |> Encode.maybe |> Encode.list), Argument.optional "format_not" filledInOptionals____.format_not (Encode.enum AniList.Enum.MediaFormat.toString), Argument.optional "format_not_in" filledInOptionals____.format_not_in (Encode.enum AniList.Enum.MediaFormat.toString |> Encode.maybe |> Encode.list), Argument.optional "status_in" filledInOptionals____.status_in (Encode.enum AniList.Enum.MediaStatus.toString |> Encode.maybe |> Encode.list), Argument.optional "status_not" filledInOptionals____.status_not (Encode.enum AniList.Enum.MediaStatus.toString), Argument.optional "status_not_in" filledInOptionals____.status_not_in (Encode.enum AniList.Enum.MediaStatus.toString |> Encode.maybe |> Encode.list), Argument.optional "episodes_greater" filledInOptionals____.episodes_greater Encode.int, Argument.optional "episodes_lesser" filledInOptionals____.episodes_lesser Encode.int, Argument.optional "duration_greater" filledInOptionals____.duration_greater Encode.int, Argument.optional "duration_lesser" filledInOptionals____.duration_lesser Encode.int, Argument.optional "chapters_greater" filledInOptionals____.chapters_greater Encode.int, Argument.optional "chapters_lesser" filledInOptionals____.chapters_lesser Encode.int, Argument.optional "volumes_greater" filledInOptionals____.volumes_greater Encode.int, Argument.optional "volumes_lesser" filledInOptionals____.volumes_lesser Encode.int, Argument.optional "genre_in" filledInOptionals____.genre_in (Encode.string |> Encode.maybe |> Encode.list), Argument.optional "genre_not_in" filledInOptionals____.genre_not_in (Encode.string |> Encode.maybe |> Encode.list), Argument.optional "tag_in" filledInOptionals____.tag_in (Encode.string |> Encode.maybe |> Encode.list), Argument.optional "tag_not_in" filledInOptionals____.tag_not_in (Encode.string |> Encode.maybe |> Encode.list), Argument.optional "tagCategory_in" filledInOptionals____.tagCategory_in (Encode.string |> Encode.maybe |> Encode.list), Argument.optional "tagCategory_not_in" filledInOptionals____.tagCategory_not_in (Encode.string |> Encode.maybe |> Encode.list), Argument.optional "licensedBy_in" filledInOptionals____.licensedBy_in (Encode.string |> Encode.maybe |> Encode.list), Argument.optional "averageScore_not" filledInOptionals____.averageScore_not Encode.int, Argument.optional "averageScore_greater" filledInOptionals____.averageScore_greater Encode.int, Argument.optional "averageScore_lesser" filledInOptionals____.averageScore_lesser Encode.int, Argument.optional "popularity_not" filledInOptionals____.popularity_not Encode.int, Argument.optional "popularity_greater" filledInOptionals____.popularity_greater Encode.int, Argument.optional "popularity_lesser" filledInOptionals____.popularity_lesser Encode.int, Argument.optional "source_in" filledInOptionals____.source_in (Encode.enum AniList.Enum.MediaSource.toString |> Encode.maybe |> Encode.list), Argument.optional "sort" filledInOptionals____.sort (Encode.enum AniList.Enum.MediaSort.toString |> Encode.maybe |> Encode.list) ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "Media" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias MediaTrendOptionalArguments =
    { mediaId : OptionalArgument Int
    , date : OptionalArgument Int
    , trending : OptionalArgument Int
    , averageScore : OptionalArgument Int
    , popularity : OptionalArgument Int
    , episode : OptionalArgument Int
    , releasing : OptionalArgument Bool
    , mediaId_not : OptionalArgument Int
    , mediaId_in : OptionalArgument (List (Maybe Int))
    , mediaId_not_in : OptionalArgument (List (Maybe Int))
    , date_greater : OptionalArgument Int
    , date_lesser : OptionalArgument Int
    , trending_greater : OptionalArgument Int
    , trending_lesser : OptionalArgument Int
    , trending_not : OptionalArgument Int
    , averageScore_greater : OptionalArgument Int
    , averageScore_lesser : OptionalArgument Int
    , averageScore_not : OptionalArgument Int
    , popularity_greater : OptionalArgument Int
    , popularity_lesser : OptionalArgument Int
    , popularity_not : OptionalArgument Int
    , episode_greater : OptionalArgument Int
    , episode_lesser : OptionalArgument Int
    , episode_not : OptionalArgument Int
    , sort : OptionalArgument (List (Maybe AniList.Enum.MediaTrendSort.MediaTrendSort))
    }


{-| Media Trend query

  - mediaId - Filter by the media id
  - date - Filter by date
  - trending - Filter by trending amount
  - averageScore - Filter by score
  - popularity - Filter by popularity
  - episode - Filter by episode number
  - releasing - Filter to stats recorded while the media was releasing
  - mediaId\_not - Filter by the media id
  - mediaId\_in - Filter by the media id
  - mediaId\_not\_in - Filter by the media id
  - date\_greater - Filter by date
  - date\_lesser - Filter by date
  - trending\_greater - Filter by trending amount
  - trending\_lesser - Filter by trending amount
  - trending\_not - Filter by trending amount
  - averageScore\_greater - Filter by score
  - averageScore\_lesser - Filter by score
  - averageScore\_not - Filter by score
  - popularity\_greater - Filter by popularity
  - popularity\_lesser - Filter by popularity
  - popularity\_not - Filter by popularity
  - episode\_greater - Filter by episode number
  - episode\_lesser - Filter by episode number
  - episode\_not - Filter by episode number
  - sort - The order the results will be returned in

-}
mediaTrend :
    (MediaTrendOptionalArguments -> MediaTrendOptionalArguments)
    -> SelectionSet decodesTo AniList.Object.MediaTrend
    -> SelectionSet (Maybe decodesTo) RootQuery
mediaTrend fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { mediaId = Absent, date = Absent, trending = Absent, averageScore = Absent, popularity = Absent, episode = Absent, releasing = Absent, mediaId_not = Absent, mediaId_in = Absent, mediaId_not_in = Absent, date_greater = Absent, date_lesser = Absent, trending_greater = Absent, trending_lesser = Absent, trending_not = Absent, averageScore_greater = Absent, averageScore_lesser = Absent, averageScore_not = Absent, popularity_greater = Absent, popularity_lesser = Absent, popularity_not = Absent, episode_greater = Absent, episode_lesser = Absent, episode_not = Absent, sort = Absent }

        optionalArgs____ =
            [ Argument.optional "mediaId" filledInOptionals____.mediaId Encode.int, Argument.optional "date" filledInOptionals____.date Encode.int, Argument.optional "trending" filledInOptionals____.trending Encode.int, Argument.optional "averageScore" filledInOptionals____.averageScore Encode.int, Argument.optional "popularity" filledInOptionals____.popularity Encode.int, Argument.optional "episode" filledInOptionals____.episode Encode.int, Argument.optional "releasing" filledInOptionals____.releasing Encode.bool, Argument.optional "mediaId_not" filledInOptionals____.mediaId_not Encode.int, Argument.optional "mediaId_in" filledInOptionals____.mediaId_in (Encode.int |> Encode.maybe |> Encode.list), Argument.optional "mediaId_not_in" filledInOptionals____.mediaId_not_in (Encode.int |> Encode.maybe |> Encode.list), Argument.optional "date_greater" filledInOptionals____.date_greater Encode.int, Argument.optional "date_lesser" filledInOptionals____.date_lesser Encode.int, Argument.optional "trending_greater" filledInOptionals____.trending_greater Encode.int, Argument.optional "trending_lesser" filledInOptionals____.trending_lesser Encode.int, Argument.optional "trending_not" filledInOptionals____.trending_not Encode.int, Argument.optional "averageScore_greater" filledInOptionals____.averageScore_greater Encode.int, Argument.optional "averageScore_lesser" filledInOptionals____.averageScore_lesser Encode.int, Argument.optional "averageScore_not" filledInOptionals____.averageScore_not Encode.int, Argument.optional "popularity_greater" filledInOptionals____.popularity_greater Encode.int, Argument.optional "popularity_lesser" filledInOptionals____.popularity_lesser Encode.int, Argument.optional "popularity_not" filledInOptionals____.popularity_not Encode.int, Argument.optional "episode_greater" filledInOptionals____.episode_greater Encode.int, Argument.optional "episode_lesser" filledInOptionals____.episode_lesser Encode.int, Argument.optional "episode_not" filledInOptionals____.episode_not Encode.int, Argument.optional "sort" filledInOptionals____.sort (Encode.enum AniList.Enum.MediaTrendSort.toString |> Encode.maybe |> Encode.list) ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "MediaTrend" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias AiringScheduleOptionalArguments =
    { id : OptionalArgument Int
    , mediaId : OptionalArgument Int
    , episode : OptionalArgument Int
    , airingAt : OptionalArgument Int
    , notYetAired : OptionalArgument Bool
    , id_not : OptionalArgument Int
    , id_in : OptionalArgument (List (Maybe Int))
    , id_not_in : OptionalArgument (List (Maybe Int))
    , mediaId_not : OptionalArgument Int
    , mediaId_in : OptionalArgument (List (Maybe Int))
    , mediaId_not_in : OptionalArgument (List (Maybe Int))
    , episode_not : OptionalArgument Int
    , episode_in : OptionalArgument (List (Maybe Int))
    , episode_not_in : OptionalArgument (List (Maybe Int))
    , episode_greater : OptionalArgument Int
    , episode_lesser : OptionalArgument Int
    , airingAt_greater : OptionalArgument Int
    , airingAt_lesser : OptionalArgument Int
    , sort : OptionalArgument (List (Maybe AniList.Enum.AiringSort.AiringSort))
    }


{-| Airing schedule query

  - id - Filter by the id of the airing schedule item
  - mediaId - Filter by the id of associated media
  - episode - Filter by the airing episode number
  - airingAt - Filter by the time of airing
  - notYetAired - Filter to episodes that haven't yet aired
  - id\_not - Filter by the id of the airing schedule item
  - id\_in - Filter by the id of the airing schedule item
  - id\_not\_in - Filter by the id of the airing schedule item
  - mediaId\_not - Filter by the id of associated media
  - mediaId\_in - Filter by the id of associated media
  - mediaId\_not\_in - Filter by the id of associated media
  - episode\_not - Filter by the airing episode number
  - episode\_in - Filter by the airing episode number
  - episode\_not\_in - Filter by the airing episode number
  - episode\_greater - Filter by the airing episode number
  - episode\_lesser - Filter by the airing episode number
  - airingAt\_greater - Filter by the time of airing
  - airingAt\_lesser - Filter by the time of airing
  - sort - The order the results will be returned in

-}
airingSchedule :
    (AiringScheduleOptionalArguments -> AiringScheduleOptionalArguments)
    -> SelectionSet decodesTo AniList.Object.AiringSchedule
    -> SelectionSet (Maybe decodesTo) RootQuery
airingSchedule fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { id = Absent, mediaId = Absent, episode = Absent, airingAt = Absent, notYetAired = Absent, id_not = Absent, id_in = Absent, id_not_in = Absent, mediaId_not = Absent, mediaId_in = Absent, mediaId_not_in = Absent, episode_not = Absent, episode_in = Absent, episode_not_in = Absent, episode_greater = Absent, episode_lesser = Absent, airingAt_greater = Absent, airingAt_lesser = Absent, sort = Absent }

        optionalArgs____ =
            [ Argument.optional "id" filledInOptionals____.id Encode.int, Argument.optional "mediaId" filledInOptionals____.mediaId Encode.int, Argument.optional "episode" filledInOptionals____.episode Encode.int, Argument.optional "airingAt" filledInOptionals____.airingAt Encode.int, Argument.optional "notYetAired" filledInOptionals____.notYetAired Encode.bool, Argument.optional "id_not" filledInOptionals____.id_not Encode.int, Argument.optional "id_in" filledInOptionals____.id_in (Encode.int |> Encode.maybe |> Encode.list), Argument.optional "id_not_in" filledInOptionals____.id_not_in (Encode.int |> Encode.maybe |> Encode.list), Argument.optional "mediaId_not" filledInOptionals____.mediaId_not Encode.int, Argument.optional "mediaId_in" filledInOptionals____.mediaId_in (Encode.int |> Encode.maybe |> Encode.list), Argument.optional "mediaId_not_in" filledInOptionals____.mediaId_not_in (Encode.int |> Encode.maybe |> Encode.list), Argument.optional "episode_not" filledInOptionals____.episode_not Encode.int, Argument.optional "episode_in" filledInOptionals____.episode_in (Encode.int |> Encode.maybe |> Encode.list), Argument.optional "episode_not_in" filledInOptionals____.episode_not_in (Encode.int |> Encode.maybe |> Encode.list), Argument.optional "episode_greater" filledInOptionals____.episode_greater Encode.int, Argument.optional "episode_lesser" filledInOptionals____.episode_lesser Encode.int, Argument.optional "airingAt_greater" filledInOptionals____.airingAt_greater Encode.int, Argument.optional "airingAt_lesser" filledInOptionals____.airingAt_lesser Encode.int, Argument.optional "sort" filledInOptionals____.sort (Encode.enum AniList.Enum.AiringSort.toString |> Encode.maybe |> Encode.list) ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "AiringSchedule" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias CharacterOptionalArguments =
    { id : OptionalArgument Int
    , isBirthday : OptionalArgument Bool
    , search : OptionalArgument String
    , id_not : OptionalArgument Int
    , id_in : OptionalArgument (List (Maybe Int))
    , id_not_in : OptionalArgument (List (Maybe Int))
    , sort : OptionalArgument (List (Maybe AniList.Enum.CharacterSort.CharacterSort))
    }


{-| Character query

  - id - Filter by character id
  - isBirthday - Filter by character by if its their birthday today
  - search - Filter by search query
  - id\_not - Filter by character id
  - id\_in - Filter by character id
  - id\_not\_in - Filter by character id
  - sort - The order the results will be returned in

-}
character :
    (CharacterOptionalArguments -> CharacterOptionalArguments)
    -> SelectionSet decodesTo AniList.Object.Character
    -> SelectionSet (Maybe decodesTo) RootQuery
character fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { id = Absent, isBirthday = Absent, search = Absent, id_not = Absent, id_in = Absent, id_not_in = Absent, sort = Absent }

        optionalArgs____ =
            [ Argument.optional "id" filledInOptionals____.id Encode.int, Argument.optional "isBirthday" filledInOptionals____.isBirthday Encode.bool, Argument.optional "search" filledInOptionals____.search Encode.string, Argument.optional "id_not" filledInOptionals____.id_not Encode.int, Argument.optional "id_in" filledInOptionals____.id_in (Encode.int |> Encode.maybe |> Encode.list), Argument.optional "id_not_in" filledInOptionals____.id_not_in (Encode.int |> Encode.maybe |> Encode.list), Argument.optional "sort" filledInOptionals____.sort (Encode.enum AniList.Enum.CharacterSort.toString |> Encode.maybe |> Encode.list) ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "Character" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias StaffOptionalArguments =
    { id : OptionalArgument Int
    , isBirthday : OptionalArgument Bool
    , search : OptionalArgument String
    , id_not : OptionalArgument Int
    , id_in : OptionalArgument (List (Maybe Int))
    , id_not_in : OptionalArgument (List (Maybe Int))
    , sort : OptionalArgument (List (Maybe AniList.Enum.StaffSort.StaffSort))
    }


{-| Staff query

  - id - Filter by the staff id
  - isBirthday - Filter by staff by if its their birthday today
  - search - Filter by search query
  - id\_not - Filter by the staff id
  - id\_in - Filter by the staff id
  - id\_not\_in - Filter by the staff id
  - sort - The order the results will be returned in

-}
staff :
    (StaffOptionalArguments -> StaffOptionalArguments)
    -> SelectionSet decodesTo AniList.Object.Staff
    -> SelectionSet (Maybe decodesTo) RootQuery
staff fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { id = Absent, isBirthday = Absent, search = Absent, id_not = Absent, id_in = Absent, id_not_in = Absent, sort = Absent }

        optionalArgs____ =
            [ Argument.optional "id" filledInOptionals____.id Encode.int, Argument.optional "isBirthday" filledInOptionals____.isBirthday Encode.bool, Argument.optional "search" filledInOptionals____.search Encode.string, Argument.optional "id_not" filledInOptionals____.id_not Encode.int, Argument.optional "id_in" filledInOptionals____.id_in (Encode.int |> Encode.maybe |> Encode.list), Argument.optional "id_not_in" filledInOptionals____.id_not_in (Encode.int |> Encode.maybe |> Encode.list), Argument.optional "sort" filledInOptionals____.sort (Encode.enum AniList.Enum.StaffSort.toString |> Encode.maybe |> Encode.list) ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "Staff" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias MediaListOptionalArguments =
    { id : OptionalArgument Int
    , userId : OptionalArgument Int
    , userName : OptionalArgument String
    , type_ : OptionalArgument AniList.Enum.MediaType.MediaType
    , status : OptionalArgument AniList.Enum.MediaListStatus.MediaListStatus
    , mediaId : OptionalArgument Int
    , isFollowing : OptionalArgument Bool
    , notes : OptionalArgument String
    , startedAt : OptionalArgument AniList.ScalarCodecs.FuzzyDateInt
    , completedAt : OptionalArgument AniList.ScalarCodecs.FuzzyDateInt
    , compareWithAuthList : OptionalArgument Bool
    , userId_in : OptionalArgument (List (Maybe Int))
    , status_in : OptionalArgument (List (Maybe AniList.Enum.MediaListStatus.MediaListStatus))
    , status_not_in : OptionalArgument (List (Maybe AniList.Enum.MediaListStatus.MediaListStatus))
    , status_not : OptionalArgument AniList.Enum.MediaListStatus.MediaListStatus
    , mediaId_in : OptionalArgument (List (Maybe Int))
    , mediaId_not_in : OptionalArgument (List (Maybe Int))
    , notes_like : OptionalArgument String
    , startedAt_greater : OptionalArgument AniList.ScalarCodecs.FuzzyDateInt
    , startedAt_lesser : OptionalArgument AniList.ScalarCodecs.FuzzyDateInt
    , startedAt_like : OptionalArgument String
    , completedAt_greater : OptionalArgument AniList.ScalarCodecs.FuzzyDateInt
    , completedAt_lesser : OptionalArgument AniList.ScalarCodecs.FuzzyDateInt
    , completedAt_like : OptionalArgument String
    , sort : OptionalArgument (List (Maybe AniList.Enum.MediaListSort.MediaListSort))
    }


{-| Media list query

  - id - Filter by a list entry's id
  - userId - Filter by a user's id
  - userName - Filter by a user's name
  - type\_ - Filter by the list entries media type
  - status - Filter by the watching/reading status
  - mediaId - Filter by the media id of the list entry
  - isFollowing - Filter list entries to users who are being followed by the authenticated user
  - notes - Filter by note words and #tags
  - startedAt - Filter by the date the user started the media
  - completedAt - Filter by the date the user completed the media
  - compareWithAuthList - Limit to only entries also on the auth user's list. Requires user id or name arguments.
  - userId\_in - Filter by a user's id
  - status\_in - Filter by the watching/reading status
  - status\_not\_in - Filter by the watching/reading status
  - status\_not - Filter by the watching/reading status
  - mediaId\_in - Filter by the media id of the list entry
  - mediaId\_not\_in - Filter by the media id of the list entry
  - notes\_like - Filter by note words and #tags
  - startedAt\_greater - Filter by the date the user started the media
  - startedAt\_lesser - Filter by the date the user started the media
  - startedAt\_like - Filter by the date the user started the media
  - completedAt\_greater - Filter by the date the user completed the media
  - completedAt\_lesser - Filter by the date the user completed the media
  - completedAt\_like - Filter by the date the user completed the media
  - sort - The order the results will be returned in

-}
mediaList :
    (MediaListOptionalArguments -> MediaListOptionalArguments)
    -> SelectionSet decodesTo AniList.Object.MediaList
    -> SelectionSet (Maybe decodesTo) RootQuery
mediaList fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { id = Absent, userId = Absent, userName = Absent, type_ = Absent, status = Absent, mediaId = Absent, isFollowing = Absent, notes = Absent, startedAt = Absent, completedAt = Absent, compareWithAuthList = Absent, userId_in = Absent, status_in = Absent, status_not_in = Absent, status_not = Absent, mediaId_in = Absent, mediaId_not_in = Absent, notes_like = Absent, startedAt_greater = Absent, startedAt_lesser = Absent, startedAt_like = Absent, completedAt_greater = Absent, completedAt_lesser = Absent, completedAt_like = Absent, sort = Absent }

        optionalArgs____ =
            [ Argument.optional "id" filledInOptionals____.id Encode.int, Argument.optional "userId" filledInOptionals____.userId Encode.int, Argument.optional "userName" filledInOptionals____.userName Encode.string, Argument.optional "type" filledInOptionals____.type_ (Encode.enum AniList.Enum.MediaType.toString), Argument.optional "status" filledInOptionals____.status (Encode.enum AniList.Enum.MediaListStatus.toString), Argument.optional "mediaId" filledInOptionals____.mediaId Encode.int, Argument.optional "isFollowing" filledInOptionals____.isFollowing Encode.bool, Argument.optional "notes" filledInOptionals____.notes Encode.string, Argument.optional "startedAt" filledInOptionals____.startedAt (AniList.ScalarCodecs.codecs |> AniList.Scalar.unwrapEncoder .codecFuzzyDateInt), Argument.optional "completedAt" filledInOptionals____.completedAt (AniList.ScalarCodecs.codecs |> AniList.Scalar.unwrapEncoder .codecFuzzyDateInt), Argument.optional "compareWithAuthList" filledInOptionals____.compareWithAuthList Encode.bool, Argument.optional "userId_in" filledInOptionals____.userId_in (Encode.int |> Encode.maybe |> Encode.list), Argument.optional "status_in" filledInOptionals____.status_in (Encode.enum AniList.Enum.MediaListStatus.toString |> Encode.maybe |> Encode.list), Argument.optional "status_not_in" filledInOptionals____.status_not_in (Encode.enum AniList.Enum.MediaListStatus.toString |> Encode.maybe |> Encode.list), Argument.optional "status_not" filledInOptionals____.status_not (Encode.enum AniList.Enum.MediaListStatus.toString), Argument.optional "mediaId_in" filledInOptionals____.mediaId_in (Encode.int |> Encode.maybe |> Encode.list), Argument.optional "mediaId_not_in" filledInOptionals____.mediaId_not_in (Encode.int |> Encode.maybe |> Encode.list), Argument.optional "notes_like" filledInOptionals____.notes_like Encode.string, Argument.optional "startedAt_greater" filledInOptionals____.startedAt_greater (AniList.ScalarCodecs.codecs |> AniList.Scalar.unwrapEncoder .codecFuzzyDateInt), Argument.optional "startedAt_lesser" filledInOptionals____.startedAt_lesser (AniList.ScalarCodecs.codecs |> AniList.Scalar.unwrapEncoder .codecFuzzyDateInt), Argument.optional "startedAt_like" filledInOptionals____.startedAt_like Encode.string, Argument.optional "completedAt_greater" filledInOptionals____.completedAt_greater (AniList.ScalarCodecs.codecs |> AniList.Scalar.unwrapEncoder .codecFuzzyDateInt), Argument.optional "completedAt_lesser" filledInOptionals____.completedAt_lesser (AniList.ScalarCodecs.codecs |> AniList.Scalar.unwrapEncoder .codecFuzzyDateInt), Argument.optional "completedAt_like" filledInOptionals____.completedAt_like Encode.string, Argument.optional "sort" filledInOptionals____.sort (Encode.enum AniList.Enum.MediaListSort.toString |> Encode.maybe |> Encode.list) ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "MediaList" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias MediaListCollectionOptionalArguments =
    { userId : OptionalArgument Int
    , userName : OptionalArgument String
    , type_ : OptionalArgument AniList.Enum.MediaType.MediaType
    , status : OptionalArgument AniList.Enum.MediaListStatus.MediaListStatus
    , notes : OptionalArgument String
    , startedAt : OptionalArgument AniList.ScalarCodecs.FuzzyDateInt
    , completedAt : OptionalArgument AniList.ScalarCodecs.FuzzyDateInt
    , forceSingleCompletedList : OptionalArgument Bool
    , chunk : OptionalArgument Int
    , perChunk : OptionalArgument Int
    , status_in : OptionalArgument (List (Maybe AniList.Enum.MediaListStatus.MediaListStatus))
    , status_not_in : OptionalArgument (List (Maybe AniList.Enum.MediaListStatus.MediaListStatus))
    , status_not : OptionalArgument AniList.Enum.MediaListStatus.MediaListStatus
    , notes_like : OptionalArgument String
    , startedAt_greater : OptionalArgument AniList.ScalarCodecs.FuzzyDateInt
    , startedAt_lesser : OptionalArgument AniList.ScalarCodecs.FuzzyDateInt
    , startedAt_like : OptionalArgument String
    , completedAt_greater : OptionalArgument AniList.ScalarCodecs.FuzzyDateInt
    , completedAt_lesser : OptionalArgument AniList.ScalarCodecs.FuzzyDateInt
    , completedAt_like : OptionalArgument String
    , sort : OptionalArgument (List (Maybe AniList.Enum.MediaListSort.MediaListSort))
    }


{-| Media list collection query, provides list pre-grouped by status & custom lists. User ID and Media Type arguments required.

  - userId - Filter by a user's id
  - userName - Filter by a user's name
  - type\_ - Filter by the list entries media type
  - status - Filter by the watching/reading status
  - notes - Filter by note words and #tags
  - startedAt - Filter by the date the user started the media
  - completedAt - Filter by the date the user completed the media
  - forceSingleCompletedList - Always return completed list entries in one group, overriding the user's split completed option.
  - chunk - Which chunk of list entries to load
  - perChunk - The amount of entries per chunk, max 500
  - status\_in - Filter by the watching/reading status
  - status\_not\_in - Filter by the watching/reading status
  - status\_not - Filter by the watching/reading status
  - notes\_like - Filter by note words and #tags
  - startedAt\_greater - Filter by the date the user started the media
  - startedAt\_lesser - Filter by the date the user started the media
  - startedAt\_like - Filter by the date the user started the media
  - completedAt\_greater - Filter by the date the user completed the media
  - completedAt\_lesser - Filter by the date the user completed the media
  - completedAt\_like - Filter by the date the user completed the media
  - sort - The order the results will be returned in

-}
mediaListCollection :
    (MediaListCollectionOptionalArguments -> MediaListCollectionOptionalArguments)
    -> SelectionSet decodesTo AniList.Object.MediaListCollection
    -> SelectionSet (Maybe decodesTo) RootQuery
mediaListCollection fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { userId = Absent, userName = Absent, type_ = Absent, status = Absent, notes = Absent, startedAt = Absent, completedAt = Absent, forceSingleCompletedList = Absent, chunk = Absent, perChunk = Absent, status_in = Absent, status_not_in = Absent, status_not = Absent, notes_like = Absent, startedAt_greater = Absent, startedAt_lesser = Absent, startedAt_like = Absent, completedAt_greater = Absent, completedAt_lesser = Absent, completedAt_like = Absent, sort = Absent }

        optionalArgs____ =
            [ Argument.optional "userId" filledInOptionals____.userId Encode.int, Argument.optional "userName" filledInOptionals____.userName Encode.string, Argument.optional "type" filledInOptionals____.type_ (Encode.enum AniList.Enum.MediaType.toString), Argument.optional "status" filledInOptionals____.status (Encode.enum AniList.Enum.MediaListStatus.toString), Argument.optional "notes" filledInOptionals____.notes Encode.string, Argument.optional "startedAt" filledInOptionals____.startedAt (AniList.ScalarCodecs.codecs |> AniList.Scalar.unwrapEncoder .codecFuzzyDateInt), Argument.optional "completedAt" filledInOptionals____.completedAt (AniList.ScalarCodecs.codecs |> AniList.Scalar.unwrapEncoder .codecFuzzyDateInt), Argument.optional "forceSingleCompletedList" filledInOptionals____.forceSingleCompletedList Encode.bool, Argument.optional "chunk" filledInOptionals____.chunk Encode.int, Argument.optional "perChunk" filledInOptionals____.perChunk Encode.int, Argument.optional "status_in" filledInOptionals____.status_in (Encode.enum AniList.Enum.MediaListStatus.toString |> Encode.maybe |> Encode.list), Argument.optional "status_not_in" filledInOptionals____.status_not_in (Encode.enum AniList.Enum.MediaListStatus.toString |> Encode.maybe |> Encode.list), Argument.optional "status_not" filledInOptionals____.status_not (Encode.enum AniList.Enum.MediaListStatus.toString), Argument.optional "notes_like" filledInOptionals____.notes_like Encode.string, Argument.optional "startedAt_greater" filledInOptionals____.startedAt_greater (AniList.ScalarCodecs.codecs |> AniList.Scalar.unwrapEncoder .codecFuzzyDateInt), Argument.optional "startedAt_lesser" filledInOptionals____.startedAt_lesser (AniList.ScalarCodecs.codecs |> AniList.Scalar.unwrapEncoder .codecFuzzyDateInt), Argument.optional "startedAt_like" filledInOptionals____.startedAt_like Encode.string, Argument.optional "completedAt_greater" filledInOptionals____.completedAt_greater (AniList.ScalarCodecs.codecs |> AniList.Scalar.unwrapEncoder .codecFuzzyDateInt), Argument.optional "completedAt_lesser" filledInOptionals____.completedAt_lesser (AniList.ScalarCodecs.codecs |> AniList.Scalar.unwrapEncoder .codecFuzzyDateInt), Argument.optional "completedAt_like" filledInOptionals____.completedAt_like Encode.string, Argument.optional "sort" filledInOptionals____.sort (Encode.enum AniList.Enum.MediaListSort.toString |> Encode.maybe |> Encode.list) ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "MediaListCollection" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


{-| Collection of all the possible media genres
-}
genreCollection : SelectionSet (Maybe (List (Maybe String))) RootQuery
genreCollection =
    Object.selectionForField "(Maybe (List (Maybe String)))" "GenreCollection" [] (Decode.string |> Decode.nullable |> Decode.list |> Decode.nullable)


type alias MediaTagCollectionOptionalArguments =
    { status : OptionalArgument Int }


{-| Collection of all the possible media tags

  - status - Mod Only

-}
mediaTagCollection :
    (MediaTagCollectionOptionalArguments -> MediaTagCollectionOptionalArguments)
    -> SelectionSet decodesTo AniList.Object.MediaTag
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
mediaTagCollection fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { status = Absent }

        optionalArgs____ =
            [ Argument.optional "status" filledInOptionals____.status Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "MediaTagCollection" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UserOptionalArguments =
    { id : OptionalArgument Int
    , name : OptionalArgument String
    , isModerator : OptionalArgument Bool
    , search : OptionalArgument String
    , sort : OptionalArgument (List (Maybe AniList.Enum.UserSort.UserSort))
    }


{-| User query

  - id - Filter by the user id
  - name - Filter by the name of the user
  - isModerator - Filter to moderators only if true
  - search - Filter by search query
  - sort - The order the results will be returned in

-}
user :
    (UserOptionalArguments -> UserOptionalArguments)
    -> SelectionSet decodesTo AniList.Object.User
    -> SelectionSet (Maybe decodesTo) RootQuery
user fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { id = Absent, name = Absent, isModerator = Absent, search = Absent, sort = Absent }

        optionalArgs____ =
            [ Argument.optional "id" filledInOptionals____.id Encode.int, Argument.optional "name" filledInOptionals____.name Encode.string, Argument.optional "isModerator" filledInOptionals____.isModerator Encode.bool, Argument.optional "search" filledInOptionals____.search Encode.string, Argument.optional "sort" filledInOptionals____.sort (Encode.enum AniList.Enum.UserSort.toString |> Encode.maybe |> Encode.list) ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "User" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


{-| Get the currently authenticated user
-}
viewer :
    SelectionSet decodesTo AniList.Object.User
    -> SelectionSet (Maybe decodesTo) RootQuery
viewer object____ =
    Object.selectionForCompositeField "Viewer" [] object____ (Basics.identity >> Decode.nullable)


type alias NotificationOptionalArguments =
    { type_ : OptionalArgument AniList.Enum.NotificationType.NotificationType
    , resetNotificationCount : OptionalArgument Bool
    , type_in : OptionalArgument (List (Maybe AniList.Enum.NotificationType.NotificationType))
    }


{-| Notification query

  - type\_ - Filter by the type of notifications
  - resetNotificationCount - Reset the unread notification count to 0 on load
  - type\_in - Filter by the type of notifications

-}
notification :
    (NotificationOptionalArguments -> NotificationOptionalArguments)
    -> SelectionSet decodesTo AniList.Union.NotificationUnion
    -> SelectionSet (Maybe decodesTo) RootQuery
notification fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { type_ = Absent, resetNotificationCount = Absent, type_in = Absent }

        optionalArgs____ =
            [ Argument.optional "type" filledInOptionals____.type_ (Encode.enum AniList.Enum.NotificationType.toString), Argument.optional "resetNotificationCount" filledInOptionals____.resetNotificationCount Encode.bool, Argument.optional "type_in" filledInOptionals____.type_in (Encode.enum AniList.Enum.NotificationType.toString |> Encode.maybe |> Encode.list) ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "Notification" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias StudioOptionalArguments =
    { id : OptionalArgument Int
    , search : OptionalArgument String
    , id_not : OptionalArgument Int
    , id_in : OptionalArgument (List (Maybe Int))
    , id_not_in : OptionalArgument (List (Maybe Int))
    , sort : OptionalArgument (List (Maybe AniList.Enum.StudioSort.StudioSort))
    }


{-| Studio query

  - id - Filter by the studio id
  - search - Filter by search query
  - id\_not - Filter by the studio id
  - id\_in - Filter by the studio id
  - id\_not\_in - Filter by the studio id
  - sort - The order the results will be returned in

-}
studio :
    (StudioOptionalArguments -> StudioOptionalArguments)
    -> SelectionSet decodesTo AniList.Object.Studio
    -> SelectionSet (Maybe decodesTo) RootQuery
studio fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { id = Absent, search = Absent, id_not = Absent, id_in = Absent, id_not_in = Absent, sort = Absent }

        optionalArgs____ =
            [ Argument.optional "id" filledInOptionals____.id Encode.int, Argument.optional "search" filledInOptionals____.search Encode.string, Argument.optional "id_not" filledInOptionals____.id_not Encode.int, Argument.optional "id_in" filledInOptionals____.id_in (Encode.int |> Encode.maybe |> Encode.list), Argument.optional "id_not_in" filledInOptionals____.id_not_in (Encode.int |> Encode.maybe |> Encode.list), Argument.optional "sort" filledInOptionals____.sort (Encode.enum AniList.Enum.StudioSort.toString |> Encode.maybe |> Encode.list) ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "Studio" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias ReviewOptionalArguments =
    { id : OptionalArgument Int
    , mediaId : OptionalArgument Int
    , userId : OptionalArgument Int
    , mediaType : OptionalArgument AniList.Enum.MediaType.MediaType
    , sort : OptionalArgument (List (Maybe AniList.Enum.ReviewSort.ReviewSort))
    }


{-| Review query

  - id - Filter by Review id
  - mediaId - Filter by media id
  - userId - Filter by user id
  - mediaType - Filter by media type
  - sort - The order the results will be returned in

-}
review :
    (ReviewOptionalArguments -> ReviewOptionalArguments)
    -> SelectionSet decodesTo AniList.Object.Review
    -> SelectionSet (Maybe decodesTo) RootQuery
review fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { id = Absent, mediaId = Absent, userId = Absent, mediaType = Absent, sort = Absent }

        optionalArgs____ =
            [ Argument.optional "id" filledInOptionals____.id Encode.int, Argument.optional "mediaId" filledInOptionals____.mediaId Encode.int, Argument.optional "userId" filledInOptionals____.userId Encode.int, Argument.optional "mediaType" filledInOptionals____.mediaType (Encode.enum AniList.Enum.MediaType.toString), Argument.optional "sort" filledInOptionals____.sort (Encode.enum AniList.Enum.ReviewSort.toString |> Encode.maybe |> Encode.list) ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "Review" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias ActivityOptionalArguments =
    { id : OptionalArgument Int
    , userId : OptionalArgument Int
    , messengerId : OptionalArgument Int
    , mediaId : OptionalArgument Int
    , type_ : OptionalArgument AniList.Enum.ActivityType.ActivityType
    , isFollowing : OptionalArgument Bool
    , hasReplies : OptionalArgument Bool
    , hasRepliesOrTypeText : OptionalArgument Bool
    , createdAt : OptionalArgument Int
    , id_not : OptionalArgument Int
    , id_in : OptionalArgument (List (Maybe Int))
    , id_not_in : OptionalArgument (List (Maybe Int))
    , userId_not : OptionalArgument Int
    , userId_in : OptionalArgument (List (Maybe Int))
    , userId_not_in : OptionalArgument (List (Maybe Int))
    , messengerId_not : OptionalArgument Int
    , messengerId_in : OptionalArgument (List (Maybe Int))
    , messengerId_not_in : OptionalArgument (List (Maybe Int))
    , mediaId_not : OptionalArgument Int
    , mediaId_in : OptionalArgument (List (Maybe Int))
    , mediaId_not_in : OptionalArgument (List (Maybe Int))
    , type_not : OptionalArgument AniList.Enum.ActivityType.ActivityType
    , type_in : OptionalArgument (List (Maybe AniList.Enum.ActivityType.ActivityType))
    , type_not_in : OptionalArgument (List (Maybe AniList.Enum.ActivityType.ActivityType))
    , createdAt_greater : OptionalArgument Int
    , createdAt_lesser : OptionalArgument Int
    , sort : OptionalArgument (List (Maybe AniList.Enum.ActivitySort.ActivitySort))
    }


{-| Activity query

  - id - Filter by the activity id
  - userId - Filter by the owner user id
  - messengerId - Filter by the id of the user who sent a message
  - mediaId - Filter by the associated media id of the activity
  - type\_ - Filter by the type of activity
  - isFollowing - Filter activity to users who are being followed by the authenticated user
  - hasReplies - Filter activity to only activity with replies
  - hasRepliesOrTypeText - Filter activity to only activity with replies or is of type text
  - createdAt - Filter by the time the activity was created
  - id\_not - Filter by the activity id
  - id\_in - Filter by the activity id
  - id\_not\_in - Filter by the activity id
  - userId\_not - Filter by the owner user id
  - userId\_in - Filter by the owner user id
  - userId\_not\_in - Filter by the owner user id
  - messengerId\_not - Filter by the id of the user who sent a message
  - messengerId\_in - Filter by the id of the user who sent a message
  - messengerId\_not\_in - Filter by the id of the user who sent a message
  - mediaId\_not - Filter by the associated media id of the activity
  - mediaId\_in - Filter by the associated media id of the activity
  - mediaId\_not\_in - Filter by the associated media id of the activity
  - type\_not - Filter by the type of activity
  - type\_in - Filter by the type of activity
  - type\_not\_in - Filter by the type of activity
  - createdAt\_greater - Filter by the time the activity was created
  - createdAt\_lesser - Filter by the time the activity was created
  - sort - The order the results will be returned in

-}
activity :
    (ActivityOptionalArguments -> ActivityOptionalArguments)
    -> SelectionSet decodesTo AniList.Union.ActivityUnion
    -> SelectionSet (Maybe decodesTo) RootQuery
activity fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { id = Absent, userId = Absent, messengerId = Absent, mediaId = Absent, type_ = Absent, isFollowing = Absent, hasReplies = Absent, hasRepliesOrTypeText = Absent, createdAt = Absent, id_not = Absent, id_in = Absent, id_not_in = Absent, userId_not = Absent, userId_in = Absent, userId_not_in = Absent, messengerId_not = Absent, messengerId_in = Absent, messengerId_not_in = Absent, mediaId_not = Absent, mediaId_in = Absent, mediaId_not_in = Absent, type_not = Absent, type_in = Absent, type_not_in = Absent, createdAt_greater = Absent, createdAt_lesser = Absent, sort = Absent }

        optionalArgs____ =
            [ Argument.optional "id" filledInOptionals____.id Encode.int, Argument.optional "userId" filledInOptionals____.userId Encode.int, Argument.optional "messengerId" filledInOptionals____.messengerId Encode.int, Argument.optional "mediaId" filledInOptionals____.mediaId Encode.int, Argument.optional "type" filledInOptionals____.type_ (Encode.enum AniList.Enum.ActivityType.toString), Argument.optional "isFollowing" filledInOptionals____.isFollowing Encode.bool, Argument.optional "hasReplies" filledInOptionals____.hasReplies Encode.bool, Argument.optional "hasRepliesOrTypeText" filledInOptionals____.hasRepliesOrTypeText Encode.bool, Argument.optional "createdAt" filledInOptionals____.createdAt Encode.int, Argument.optional "id_not" filledInOptionals____.id_not Encode.int, Argument.optional "id_in" filledInOptionals____.id_in (Encode.int |> Encode.maybe |> Encode.list), Argument.optional "id_not_in" filledInOptionals____.id_not_in (Encode.int |> Encode.maybe |> Encode.list), Argument.optional "userId_not" filledInOptionals____.userId_not Encode.int, Argument.optional "userId_in" filledInOptionals____.userId_in (Encode.int |> Encode.maybe |> Encode.list), Argument.optional "userId_not_in" filledInOptionals____.userId_not_in (Encode.int |> Encode.maybe |> Encode.list), Argument.optional "messengerId_not" filledInOptionals____.messengerId_not Encode.int, Argument.optional "messengerId_in" filledInOptionals____.messengerId_in (Encode.int |> Encode.maybe |> Encode.list), Argument.optional "messengerId_not_in" filledInOptionals____.messengerId_not_in (Encode.int |> Encode.maybe |> Encode.list), Argument.optional "mediaId_not" filledInOptionals____.mediaId_not Encode.int, Argument.optional "mediaId_in" filledInOptionals____.mediaId_in (Encode.int |> Encode.maybe |> Encode.list), Argument.optional "mediaId_not_in" filledInOptionals____.mediaId_not_in (Encode.int |> Encode.maybe |> Encode.list), Argument.optional "type_not" filledInOptionals____.type_not (Encode.enum AniList.Enum.ActivityType.toString), Argument.optional "type_in" filledInOptionals____.type_in (Encode.enum AniList.Enum.ActivityType.toString |> Encode.maybe |> Encode.list), Argument.optional "type_not_in" filledInOptionals____.type_not_in (Encode.enum AniList.Enum.ActivityType.toString |> Encode.maybe |> Encode.list), Argument.optional "createdAt_greater" filledInOptionals____.createdAt_greater Encode.int, Argument.optional "createdAt_lesser" filledInOptionals____.createdAt_lesser Encode.int, Argument.optional "sort" filledInOptionals____.sort (Encode.enum AniList.Enum.ActivitySort.toString |> Encode.maybe |> Encode.list) ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "Activity" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias ActivityReplyOptionalArguments =
    { id : OptionalArgument Int
    , activityId : OptionalArgument Int
    }


{-| Activity reply query

  - id - Filter by the reply id
  - activityId - Filter by the parent id

-}
activityReply :
    (ActivityReplyOptionalArguments -> ActivityReplyOptionalArguments)
    -> SelectionSet decodesTo AniList.Object.ActivityReply
    -> SelectionSet (Maybe decodesTo) RootQuery
activityReply fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { id = Absent, activityId = Absent }

        optionalArgs____ =
            [ Argument.optional "id" filledInOptionals____.id Encode.int, Argument.optional "activityId" filledInOptionals____.activityId Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "ActivityReply" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias FollowingOptionalArguments =
    { sort : OptionalArgument (List (Maybe AniList.Enum.UserSort.UserSort)) }


type alias FollowingRequiredArguments =
    { userId : Int }


{-| Follow query

  - userId - User id of the follower/followed
  - sort - The order the results will be returned in

-}
following :
    (FollowingOptionalArguments -> FollowingOptionalArguments)
    -> FollowingRequiredArguments
    -> SelectionSet decodesTo AniList.Object.User
    -> SelectionSet (Maybe decodesTo) RootQuery
following fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { sort = Absent }

        optionalArgs____ =
            [ Argument.optional "sort" filledInOptionals____.sort (Encode.enum AniList.Enum.UserSort.toString |> Encode.maybe |> Encode.list) ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "Following" (optionalArgs____ ++ [ Argument.required "userId" requiredArgs____.userId Encode.int ]) object____ (Basics.identity >> Decode.nullable)


type alias FollowerOptionalArguments =
    { sort : OptionalArgument (List (Maybe AniList.Enum.UserSort.UserSort)) }


type alias FollowerRequiredArguments =
    { userId : Int }


{-| Follow query

  - userId - User id of the follower/followed
  - sort - The order the results will be returned in

-}
follower :
    (FollowerOptionalArguments -> FollowerOptionalArguments)
    -> FollowerRequiredArguments
    -> SelectionSet decodesTo AniList.Object.User
    -> SelectionSet (Maybe decodesTo) RootQuery
follower fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { sort = Absent }

        optionalArgs____ =
            [ Argument.optional "sort" filledInOptionals____.sort (Encode.enum AniList.Enum.UserSort.toString |> Encode.maybe |> Encode.list) ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "Follower" (optionalArgs____ ++ [ Argument.required "userId" requiredArgs____.userId Encode.int ]) object____ (Basics.identity >> Decode.nullable)


type alias ThreadOptionalArguments =
    { id : OptionalArgument Int
    , userId : OptionalArgument Int
    , replyUserId : OptionalArgument Int
    , subscribed : OptionalArgument Bool
    , categoryId : OptionalArgument Int
    , mediaCategoryId : OptionalArgument Int
    , search : OptionalArgument String
    , id_in : OptionalArgument (List (Maybe Int))
    , sort : OptionalArgument (List (Maybe AniList.Enum.ThreadSort.ThreadSort))
    }


{-| Thread query

  - id - Filter by the thread id
  - userId - Filter by the user id of the thread's creator
  - replyUserId - Filter by the user id of the last user to comment on the thread
  - subscribed - Filter by if the currently authenticated user's subscribed threads
  - categoryId - Filter by thread category id
  - mediaCategoryId - Filter by thread media id category
  - search - Filter by search query
  - id\_in - Filter by the thread id
  - sort - The order the results will be returned in

-}
thread :
    (ThreadOptionalArguments -> ThreadOptionalArguments)
    -> SelectionSet decodesTo AniList.Object.Thread
    -> SelectionSet (Maybe decodesTo) RootQuery
thread fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { id = Absent, userId = Absent, replyUserId = Absent, subscribed = Absent, categoryId = Absent, mediaCategoryId = Absent, search = Absent, id_in = Absent, sort = Absent }

        optionalArgs____ =
            [ Argument.optional "id" filledInOptionals____.id Encode.int, Argument.optional "userId" filledInOptionals____.userId Encode.int, Argument.optional "replyUserId" filledInOptionals____.replyUserId Encode.int, Argument.optional "subscribed" filledInOptionals____.subscribed Encode.bool, Argument.optional "categoryId" filledInOptionals____.categoryId Encode.int, Argument.optional "mediaCategoryId" filledInOptionals____.mediaCategoryId Encode.int, Argument.optional "search" filledInOptionals____.search Encode.string, Argument.optional "id_in" filledInOptionals____.id_in (Encode.int |> Encode.maybe |> Encode.list), Argument.optional "sort" filledInOptionals____.sort (Encode.enum AniList.Enum.ThreadSort.toString |> Encode.maybe |> Encode.list) ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "Thread" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias ThreadCommentOptionalArguments =
    { id : OptionalArgument Int
    , threadId : OptionalArgument Int
    , userId : OptionalArgument Int
    , sort : OptionalArgument (List (Maybe AniList.Enum.ThreadCommentSort.ThreadCommentSort))
    }


{-| Comment query

  - id - Filter by the comment id
  - threadId - Filter by the thread id
  - userId - Filter by the user id of the comment's creator
  - sort - The order the results will be returned in

-}
threadComment :
    (ThreadCommentOptionalArguments -> ThreadCommentOptionalArguments)
    -> SelectionSet decodesTo AniList.Object.ThreadComment
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
threadComment fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { id = Absent, threadId = Absent, userId = Absent, sort = Absent }

        optionalArgs____ =
            [ Argument.optional "id" filledInOptionals____.id Encode.int, Argument.optional "threadId" filledInOptionals____.threadId Encode.int, Argument.optional "userId" filledInOptionals____.userId Encode.int, Argument.optional "sort" filledInOptionals____.sort (Encode.enum AniList.Enum.ThreadCommentSort.toString |> Encode.maybe |> Encode.list) ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "ThreadComment" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias RecommendationOptionalArguments =
    { id : OptionalArgument Int
    , mediaId : OptionalArgument Int
    , mediaRecommendationId : OptionalArgument Int
    , userId : OptionalArgument Int
    , rating : OptionalArgument Int
    , onList : OptionalArgument Bool
    , rating_greater : OptionalArgument Int
    , rating_lesser : OptionalArgument Int
    , sort : OptionalArgument (List (Maybe AniList.Enum.RecommendationSort.RecommendationSort))
    }


{-| Recommendation query

  - id - Filter by recommendation id
  - mediaId - Filter by media id
  - mediaRecommendationId - Filter by media recommendation id
  - userId - Filter by user who created the recommendation
  - rating - Filter by total rating of the recommendation
  - onList - Filter by the media on the authenticated user's lists
  - rating\_greater - Filter by total rating of the recommendation
  - rating\_lesser - Filter by total rating of the recommendation
  - sort - The order the results will be returned in

-}
recommendation :
    (RecommendationOptionalArguments -> RecommendationOptionalArguments)
    -> SelectionSet decodesTo AniList.Object.Recommendation
    -> SelectionSet (Maybe decodesTo) RootQuery
recommendation fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { id = Absent, mediaId = Absent, mediaRecommendationId = Absent, userId = Absent, rating = Absent, onList = Absent, rating_greater = Absent, rating_lesser = Absent, sort = Absent }

        optionalArgs____ =
            [ Argument.optional "id" filledInOptionals____.id Encode.int, Argument.optional "mediaId" filledInOptionals____.mediaId Encode.int, Argument.optional "mediaRecommendationId" filledInOptionals____.mediaRecommendationId Encode.int, Argument.optional "userId" filledInOptionals____.userId Encode.int, Argument.optional "rating" filledInOptionals____.rating Encode.int, Argument.optional "onList" filledInOptionals____.onList Encode.bool, Argument.optional "rating_greater" filledInOptionals____.rating_greater Encode.int, Argument.optional "rating_lesser" filledInOptionals____.rating_lesser Encode.int, Argument.optional "sort" filledInOptionals____.sort (Encode.enum AniList.Enum.RecommendationSort.toString |> Encode.maybe |> Encode.list) ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "Recommendation" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias LikeOptionalArguments =
    { likeableId : OptionalArgument Int
    , type_ : OptionalArgument AniList.Enum.LikeableType.LikeableType
    }


{-| Like query

  - likeableId - The id of the likeable type
  - type\_ - The type of model the id applies to

-}
like :
    (LikeOptionalArguments -> LikeOptionalArguments)
    -> SelectionSet decodesTo AniList.Object.User
    -> SelectionSet (Maybe decodesTo) RootQuery
like fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { likeableId = Absent, type_ = Absent }

        optionalArgs____ =
            [ Argument.optional "likeableId" filledInOptionals____.likeableId Encode.int, Argument.optional "type" filledInOptionals____.type_ (Encode.enum AniList.Enum.LikeableType.toString) ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "Like" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias MarkdownRequiredArguments =
    { markdown : String }


{-| Provide AniList markdown to be converted to html (Requires auth)

  - markdown - The markdown to be parsed to html

-}
markdown :
    MarkdownRequiredArguments
    -> SelectionSet decodesTo AniList.Object.ParsedMarkdown
    -> SelectionSet (Maybe decodesTo) RootQuery
markdown requiredArgs____ object____ =
    Object.selectionForCompositeField "Markdown" [ Argument.required "markdown" requiredArgs____.markdown Encode.string ] object____ (Basics.identity >> Decode.nullable)


aniChartUser :
    SelectionSet decodesTo AniList.Object.AniChartUser
    -> SelectionSet (Maybe decodesTo) RootQuery
aniChartUser object____ =
    Object.selectionForCompositeField "AniChartUser" [] object____ (Basics.identity >> Decode.nullable)


{-| Site statistics query
-}
siteStatistics :
    SelectionSet decodesTo AniList.Object.SiteStatistics
    -> SelectionSet (Maybe decodesTo) RootQuery
siteStatistics object____ =
    Object.selectionForCompositeField "SiteStatistics" [] object____ (Basics.identity >> Decode.nullable)
